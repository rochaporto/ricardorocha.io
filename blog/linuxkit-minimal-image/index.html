<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Ricardo Rocha"><meta name=description content="Software Engineer at CERN"><meta name=generator content="Hugo 0.60.0"><title>Building Immutable Cluster Images with LinuxKit</title><link rel="shortcut icon" href=https://ricardorocha.io/images/favicon.ico><link rel=stylesheet href=https://ricardorocha.io/css/style.css><link rel=stylesheet href=https://ricardorocha.io/css/highlight.css><link rel=stylesheet href=https://ricardorocha.io/css/monosocialiconsfont.css><link href=https://ricardorocha.io/index.xml rel=alternate type=application/rss+xml title="Ricardo Rocha"><meta property="og:title" content="Building Immutable Cluster Images with LinuxKit"><meta property="og:description" content="A simple and declarative way to maintain minimal and reproducible cluster node images"><meta property="og:type" content="article"><meta property="og:url" content="https://ricardorocha.io/blog/linuxkit-minimal-image/"><meta property="article:published_time" content="2021-02-06T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-06T00:00:00+00:00"><meta itemprop=name content="Building Immutable Cluster Images with LinuxKit"><meta itemprop=description content="A simple and declarative way to maintain minimal and reproducible cluster node images"><meta itemprop=datePublished content="2021-02-06T00:00:00&#43;00:00"><meta itemprop=dateModified content="2021-02-06T00:00:00&#43;00:00"><meta itemprop=wordCount content="916"><meta itemprop=keywords content="kubernetes,docker,containerd,linuxkit,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building Immutable Cluster Images with LinuxKit"><meta name=twitter:description content="A simple and declarative way to maintain minimal and reproducible cluster node images"><meta name=twitter:site content="@https://twitter.com/ahcorporto"></head><body><nav class=main-nav><a href=https://ricardorocha.io/><span class=arrow>‚Üê</span>Home</a>
<a href=/blog/>Blog</a>
<a href=/project>Projects</a>
<a href=/talk/>Talks</a>
<a href=/story/>Stories</a>
<a href=/about/>About</a>
<a href=https://ricardorocha.io/index.xml>RSS</a></nav><section id=wrapper><article class=post><header><h1>Building Immutable Cluster Images with LinuxKit</h1><h2 class=headline>February 6, 2021 - 5 min read<br><a href=https://ricardorocha.io/tags/kubernetes>kubernetes</a>
<a href=https://ricardorocha.io/tags/docker>docker</a>
<a href=https://ricardorocha.io/tags/containerd>containerd</a>
<a href=https://ricardorocha.io/tags/linuxkit>linuxkit</a></h2></header><section id=post-body><h3 id=tldr>TL;DR</h3><ul><li>Immutable infrastructure is a good option to avoid configuration drift</li><li>LinuxKit can produce minimal images, speeding up deployments and improving security</li><li>Containerized deployments can benefit from the above</li></ul><hr><p>One of the challenges of running large scale infrastructures is making sure
nodes are kept consistent and up to date, avoiding configuration drift. One
way of achieving this is relying on systems like CFEngine, Puppet or Chef, regularly
(re)applying the expected configuration on the nodes (<a href=https://martinfowler.com/bliki/SnowflakeServer.html>SnowFlakes</a>).
A limitation of this approach is that drift will only be spotted in areas defined under these tools&rsquo; control and
for long lived instances it's common to find inconsistencies in other areas -
practice tells us there will always be some.</p><p>An alternative is to rely on immutable infrastructure, where nodes
(<a href=https://martinfowler.com/bliki/PhoenixServer.html>PhoenixServers</a>) are launched
from a base image and never changed. Updates are done directly on the base
image (possibly created using the tools above, most often not) and nodes are recreated from
scratch, ensuring any configuration drift is removed. It also improves
reproducibility and makes deployments more predictable - including more reliable rollbacks
when needed.</p><blockquote><p><em>Uptime bragging rights will be lost, but probably not missed by many&hellip;</em></p></blockquote><p>The latter is popular in containerized environments with the nodes
being set with a small image containing only the minimal set of dependencies to
launch additional service and application containers. Tools that explore this in the Kubernetes and container area include <a href=https://rancher.com/docs/os/v1.x/en/>RancherOS</a>,
<a href=https://www.flatcar-linux.org/>Flatcar</a> (a fork from pre-RH CoreOS), <a href="https://getfedora.org/en/coreos?stream=stable">Fedora
CoreOS</a> or GCP's <a href=https://cloud.google.com/container-optimized-os/docs>Container-Optimized OS</a>. This post looks at what can be done in <a href=https://github.com/linuxkit/linuxkit>LinuxKit</a>, but the same layout
is valid for the other tools.</p><h2 id=linuxkit>LinuxKit</h2><blockquote><p><a href=https://github.com/linuxkit/linuxkit>LinuxKit</a> is a toolkit for building custom minimal, immutable Linux distributions.</p></blockquote><p>It puts special focus on providing secure defaults, reproducibility and easy
iteration. Images are built using containers for running containers - this even
includes <a href=https://github.com/linuxkit/linuxkit/blob/master/docs/kernels.md>the kernel</a>
which is also distributed as an image. It relies on <a href=https://github.com/linuxkit/linuxkit/blob/master/docs/signing.md>Notary</a>
to enforce trust by signing and verifying the images.</p><p>The layout is defined in yaml, here is an example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>kernel:
  image: linuxkit/kernel:<span style=color:#ae81ff>5.4</span><span style=color:#ae81ff>.39</span>
  cmdline: <span style=color:#e6db74>&#34;console=ttyS0&#34;</span>
init:
  - linuxkit/init:a68f9fa0c1d9dbfc9c23663749a0b7ac510cbe1c
  - linuxkit/runc:v0<span style=color:#ae81ff>.8</span>
  - linuxkit/containerd:a4aa19c608556f7d786852557c36136255220c1f
  - linuxkit/ca-certificates:v0<span style=color:#ae81ff>.8</span>
onboot:
  - name: sysctl
    image: linuxkit/sysctl:v0<span style=color:#ae81ff>.8</span>
  - name: dhcpcd
    image: linuxkit/dhcpcd:v0<span style=color:#ae81ff>.8</span>
    command: [<span style=color:#e6db74>&#34;/sbin/dhcpcd&#34;</span>, <span style=color:#e6db74>&#34;--nobackground&#34;</span>, <span style=color:#e6db74>&#34;-f&#34;</span>, <span style=color:#e6db74>&#34;/dhcpcd.conf&#34;</span>, <span style=color:#e6db74>&#34;-1&#34;</span>]
  - name: metadata
    image: linuxkit/metadata:v0<span style=color:#ae81ff>.8</span>
    command: [<span style=color:#e6db74>&#34;/usr/bin/metadata&#34;</span>, <span style=color:#e6db74>&#34;openstack&#34;</span>]
services:
  - name: rngd
    image: linuxkit/rngd:v0<span style=color:#ae81ff>.8</span>
  - name: sshd
    image: linuxkit/sshd:666b4a1a323140aa1f332826164afba506abf597
</code></pre></div><p>Each section handles the given image in a different way.</p><p><strong>kernel</strong> is a special image with the kernel and any additional modules
that get unpacked into root. You can find details on how kernel images are built
<a href=https://github.com/linuxkit/linuxkit/blob/master/docs/kernels.md>here</a>.</p><p><strong>init</strong> contains images that get unpacked into the root filesystem,
and should take care of all that is needed to get a functional containerd.</p><p><strong>onboot</strong> images are run on containerd but before any other image, sequentially, and must
succeed before the next image is run. Useful for things that need to be run
or up before long lived services are launched.</p><p><strong>services</strong> are long lived services running on containerd, with no
defined launching order (meaning you might need logic to wait for resources to be
available).</p><p>We can build the image with a single command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ linuxkit build -format qcow2-bios linuxkit.yml

$ ls -s linuxkit.qcow2 
<span style=color:#ae81ff>121288</span> linuxkit.qcow2
</code></pre></div><p>The final image is just over 120MB (vs 1.7GB of a Fedora Core image!).</p><p>In this case we include the additional <em>metadata</em>
component to handle the node configuration in an OpenStack environment and
<em>rngd</em> and <em>sshd</em> as long lived services, so the image could be even smaller -
<a href=https://github.com/linuxkit/linuxkit/tree/master/pkg>check here</a> for the
available pre-built containers, <a href=https://github.com/linuxkit/linuxkit/blob/master/docs/packages.md>and
here</a> if you
want to go ahead and turn your containerized service into a LinuxKit package.</p><h2 id=orchestration>Orchestration</h2><p>Having a small base image has multiple advantages:</p><ul><li>Fewer components, easier to maintain, improved security</li><li>Faster upgrades and efficient cluster auto scaling</li><li>Reduced load on the network and storage</li></ul><p>For a single or low number of workloads we could consider including all in
one image, but on a large infrastructure running multiple heterogeneous workloads this is not
practical. It would potentially make the image very big (breaking the purpose),
updates on a single workload would require rebuilding and redeploying the full image,
and with a single large image or multiple smaller images we still need some sort of orchestration.</p><p>A better match is to rely on a minimal image
for the base components, and rely on Kubernetes (or other orchestrator) to
handle the actual workloads. Kubernetes already does the job of ensuring the
desired workload constraints are followed - <a href=https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>Affinities</a>,
<a href=https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/>TopologyContraints</a>, <a href=https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#pod-disruption-budgets>PodDisruptionBudgets</a>, etc. -
and is designed so nodes are disposable by default and can be recreated without an
impact on the workloads (minus stateful workloads).</p><p>We end up with something like this&hellip;</p><figure><img src=/images/blog/linuxkit-k8s.png width=100%></figure><p>Both nodes and containers are handled as immutable and disposable units, but
we get finer granularity on the deployment where needed by running the
workloads in containers. A kernel upgrade means a rollout of a new base image
across the cluster (recreating the nodes), but a new release of a single
service only requires recreating the corresponding service containers.</p><p>In addition to the benefits described above, relying on immutable
infrastructure also poses a few challenges - the first debug session can be
quite frustating when <em>apt-get install</em> and similar is not possible. But the
notion of <em>everything is a container</em> picks up quickly, and keeping close by an image
with all required tools (netstat, tcpdump, and other good friends) offers an
even better way to easily and quickly debug issues on individual nodes - and
again, only when really needed.</p></section></article><aside><header><strong>Related Content</strong></header><br><ul id=post-list class="archive readmore"><li><a href=/blog/prometheus-metrics-mtail/>Blog: Generating Prometheus Metrics from Application Logs<aside class=dates>December 16, 2020, 4 min reading time</aside></a><br>Using mtail and sidecar containers to expose metrics</li><li><a href=/blog/ubuntu-setup/>Blog: Generating Prometheus Metrics from Application Logs<aside class=dates>December 16, 2020, 4 min reading time</aside></a><br>Using mtail and sidecar containers to expose metrics</li><li><a href=/blog/teleworking-setup-novpn/>Blog: A VPN-less Teleworking Setup<aside class=dates>November 16, 2020, 2 min reading time</aside></a><br>Making work from home simpler when VPNs are not an option</li><li><a href=/blog/prometheus-metrics-in-pandas/>Blog: Analysing Prometheus Metrics in Pandas<aside class=dates>November 13, 2020, 4 min reading time</aside></a><br>An example for GPU workload metrics</li><li><a href=/blog/gke-custom-containerd/>Blog: Custom Containerd Versions in GKE Clusters<aside class=dates>October 25, 2020, 3 min reading time</aside></a><br>Upgrade containerd on a GKE cluster</li></ul></aside><footer id=footer><div id=social><a class=symbol href=https://github.com/rochaporto>roundedgithub</a>
<a class=symbol href=https://www.linkedin.com/in/ricardo-rocha-739aa718>roundedlinkedin</a>
<a class=symbol href=https://twitter.com/ahcorporto>roundedtwitterbird</a></div><p class=small>Think Positive, Flaps Negative<br>@ Copyright 2021 Ricardo Rocha, Built with <a href=http://gohugo.io>Hugo</a></p></footer></section><script src=//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js></script><script src=https://ricardorocha.io/js/main.js></script><script src=https://ricardorocha.io/js/highlight.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>